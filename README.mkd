# tsh -- quick and easy testing shell

## why

I got tired of: bash/sh portability issues; writing long, complicated, test
code; weird shell constructs for simple things; constantly putting in
`&>/dev/null`; and many more.

The examples may help tell the story better.  A longer example, which also
shows you how to do TAP stuff, is [here][gpt01].

[gpt01]: https://github.com/sitaramc/gitpod/blob/master/t/t01

## guiding principle

Less typing.  Less output.

## teasers

Here are some teasers.  Details are in later sections.

### shell teasers

Teaser 1 (tedious in shell): "exit unless **both** git-daemon and git-gui RPMs
are installed"

    tsh "rpm -qa
        /git-daemon/ or need git-daemon
        /git-gui/    or need git-gui
    " || exit 1

Teaser 2 (horrible in shell): "exit if gcc 4 is missing or gcc 3 is installed"

    tsh "rpm -qa
        /gcc-4/     or please install gcc 4
        !/gcc-3/    or please remove  gcc 3
    " || exit 1

The only way I know of to do this in shell, without using at least a temp
file, is this:

    cat ~/rpm-qa |
        tee >(grep gcc-3 >/dev/null && echo please remove gcc 3 >&2) |
        grep gcc-4 >/dev/null || echo please install gcc 4

Ugh!

### perl examples

In perl, instead of calling a *program* called `tsh` you call a *function*
called `try`.

(Note: the first 5 lines will not be shown in any later examples).

    #!/usr/bin/perl
    use 5.10.0;
    use strict;
    use warnings;
    use Tsh;

    try "rpm -qa
        /gcc-4/     or please install gcc 4
        !/gcc-3/    or please remove  gcc 3
    " or die;

However, you can **do a lot more** in perl.  See detailed documentation later.

## requirements

perl 5.10.0 or later, and any posix shell that understands very simple
redirection.

## input

For **shell**, there's little more to be said.  You can supply a single
filename instead of giving the commands on the command line like we did.  You
can also supply the commands on STDIN

When you supply more than one argument, each argument is treated as being on a
separate line.  Commands are separated by newlines as well as by semicolons.

No fancy parsing is done; if you have semicolons inside some string, expect
trouble.  Patches welcome.

### syntax

You can put one command on each line, or more than one per line if you
separate them with semicolons.  Comments are allowed in the usual way.
Leading whitespace is always thrown away, but not elsewhere.  There are no
continuation lines or include files.

(When you supply commands directly as arguments, each argument is treated as a
line.  In addition, an argument may itself be multi-line, as the teaser
examples showed.  All these combinations are treated as multi-line input).

### hashhash comments (testnames)

Comment lines that start with optional whitespace, then `##` (two hash marks)
then whitespace, are treated as supplying the "name" of that test; see
the `error_list` function below.  This also serves as a progress report if you
run it at `TSH_VERBOSE=2` or higher.

## functions available to perl

For **perl**, you already saw the `try()` function above.  A lot can be done
by just passing **tsh commands** (see later) to it, but there are some more
functions available if you need them.

The following functions get you more information:

  * `rc()` -- return code of the last external command executed
  * `text()` -- combined STDOUT+STDERR of the last external command
  * `error_count()` -- number of errors in the last sequence of tsh commands
  * `error_list()` -- the list of "testnames" (see above) at which errors
    occurred

The following convenience functions are also available.  Their purpose is to
help you replace shell scripts as much as possible.

  * `put($filename, $var)` -- print the contents of the perl variable in arg-2
    to the file in arg-1.  The filename can start with a pipe character, which
    means it will then be interpreted as a process to pipe data to (but you
    *cannot* capture it's stdout or stderr).

    Examples

        put("$HOME/.foo.rc", $foo);
        # eqvt to: echo "$foo" > ~/.foo.rc

        put("| cat >> $HOME/.foo.rc", $foo);
        # eqvt to: echo "$foo" >> ~/.foo.rc

  * there is no `get()` function.  You can use backticks to get the same
    effect, although they cause an extra fork or two so it may not be as
    efficient as doing it in pure perl.  Patches welcome.

## output

The **return value** fits the language used so you can use it as a boolean as
usual.  <font color="gray">This means the **actual** value is different in
perl and in shell, since they have opposite notions of what is "true" and what
is "false".</font>

STDOUT is only used for TAP related output (see TAP section later).

The 'try()' function prints nothing by default.  The 'tsh' command prints
nothing on success, but on failure it prints a very brief error summary (like
"3 error(s)") to STDERR.

In both cases, test-specific messages (see later) are printed to STDERR.

Also in both cases, the TSH_VERBOSE env var changes the output:

  * **0**: (for 'tsh') suppress even the error summary (only exit code).
  * **1**: print test failure messages and unchecked non-zero return codes
    (i.e., when an external command fails but its exit code is ignored).
  * **2**: print each line as it is read.  Also, print the text of the special
    "hashhash" comments (see "hashhash comments" section earlier).
  * **3**: print each command as it is read.

(Setting it to 4 produces too much output to be useful most of the time).

## tsh commands in detail

### macros

Every command is first checked if a macro by that name exists.  Your current
list of macros is shown if you run 'tsh' without any arguments.  With the
default set of macros, for example, a command of `empty` will run `git commit
--allow-empty -m empty`.

The rest of the commands described below are checked only after this macro
expansion.  Macro expansion is attempted even on the result of the previous
macro expansion, so be careful you don't recurse.

### environment commands

  * `cd ...` -- does a chdir().  Without an argument it goes to `$HOME`
  * `ENV foo='bar baz'` -- sets the env var foo

### testing commands

(Also see the TAP section below for the `plan` command).

  * `ok` -- checks that the previous command's rc was 0
  * `!ok` -- similar, except negated (check that the rc was *not* 0)
  * `/pattern/` -- check that the combined STDOUT+STDERR of the last executed
    command contained a string that matched the pattern
  * `!/pattern/` -- negated version of above

#### test-specific messages

In addition, each of these can be followed by the word 'or' followed by a
**test-specific message**, like so:

    ok or hey the last command failed

### git specific commands

  * `tt` -- step the commit timestamps by one minute
  * `dc foo` -- do a dummy_commit of the file 'foo', appending a fixed known
    line to it

### external commands

Any command that is not one of the above will be treated as an external
command.

## TAP compliance

'tsh' is will produce `ok` / `not ok` lines if you run it from 'prove', or
indeed any harness that sets the `HARNESS_ACTIVE` env var.

You will need to supply a plan before the first test.  Just use the `plan N`
tsh command (where N is the number of tests you plan to run).

You may have guessed that the `plan` command is merely a convenience; if you
wish, you can check that variable and print the plan yourself.

Note: the ok/not ok messages do not contain the actual, correct, test number,
because tsh can be invoked multiple times from an outer shell script, and we
have no clean way to convey the running test number from one invocation to the
next.  This does *not* affect TAP compliance; at least it works fine with
`prove`.
